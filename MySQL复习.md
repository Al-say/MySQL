# MySQL数据库补考复习指南

## 一、选择题（40分，20题）

### 1. 基本概念
1. **数据库系统基础**
   - DB（数据库）：
     * 定义：存储在计算机内的相关数据的集合
     * 特点：结构化存储、共享性高、冗余度低
     * 实例：学生信息库、图书管理库、银行账户库
   
   - DBMS（数据库管理系统）：
     * 定义：管理数据库的软件系统
     * 功能：数据定义、数据操作、数据库运行管理、数据库建立和维护
     * 常见DBMS：MySQL、Oracle、SQL Server、PostgreSQL
   
   - DBS（数据库系统）：
     * 组成：DB + DBMS + 应用系统 + 数据库管理员(DBA)
     * 特点：统一管理、数据共享、减少冗余
   
   - 数据独立性：
     * 物理独立性：应用程序与数据存储方式无关
     * 逻辑独立性：应用程序与数据库逻辑结构无关
     * 作用：减少维护成本，提高系统可维护性

2. **三级模式结构**
   - 外模式（External Schema）：
     * 定义：用户视图级别，是用户看到的数据库的数据视图
     * 特点：一个数据库可以有多个外模式
     * 示例：不同部门看到的学生信息视图可能不同
       - 教务处：可看到所有信息
       - 任课教师：只能看到选课和成绩信息
   
   - 模式（Conceptual Schema）：
     * 定义：逻辑级别，是数据库中全体数据的逻辑结构和特征的描述
     * 特点：一个数据库只有一个模式
     * 包含内容：实体、属性、关系、约束等
   
   - 内模式（Internal Schema）：
     * 定义：物理存储级别，描述数据在存储设备上的存储方式
     * 包含内容：存储记录格式、索引组织方式、访问方法等
   
   - 两级映像：
     * 外模式/模式映像：
       - 实现数据的逻辑独立性
       - 应用程序与逻辑结构的改变无关
     * 模式/内模式映像：
       - 实现数据的物理独立性
       - 逻辑结构与物理存储无关

3. **数据模型**
   - 层次模型：
     * 结构：树形结构
     * 特点：只能表示1:n关系
     * 优点：查询效率高，层次分明
     * 缺点：不能直接表示多对多关系
   
   - 网状模型：
     * 结构：网络结构
     * 特点：可以表示m:n关系
     * 优点：能表示复杂关系
     * 缺点：结构复杂，不直观
   
   - 关系模型：
     * 结构：二维表格形式
     * 特点：
       - 每一行是一条记录
       - 每一列是一个属性
       - 关系必须是规范化的
     * 优点：
       - 结构简单清晰
       - 易于理解和使用
       - 有严密的数学理论基础
   
   - 数据模型三要素：
     * 数据结构：描述数据库的组成对象及对象之间的联系
     * 数据操作：对数据库中各种对象的操作及有关的操作规则
     * 数据约束：数据及其联系所具有的制约和依存规则

### 2. 关系数据库理论
1. **关系的基本概念**
   - 关系（表）的组成：
     * 关系模式：关系名(属性1, 属性2, ..., 属性n)
     * 关系：关系模式在某一时刻的数据集合
     * 元组（行）：表中的每一行数据
     * 属性（列）：表中的每一列
     * 域：属性的取值范围
     * 分量：元组中的一个属性值
   
   - 关系的性质：
     * 列是同质的（相同数据类型）
     * 不同列可以来自同一个域
     * 列名唯一，行列次序无关紧要
     * 任意两个元组不能完全相同
   
   - 码的概念：
     * 超键：唯一标识元组的属性集
       - 示例：学生表中，{学号}、{学号,姓名}都是超键
     * 候选键：最小超键
       - 特点：不含多余属性的超键
       - 示例：学生表中{学号}是候选键
     * 主键：人为选定的候选键
       - 作用：唯一标识每个元组
       - 示例：选择学号作为主键
     * 外键：引用另一个关系主键的属性
       - 作用：建立表间联系
       - 示例：选课表中的学号引用学生表的主键

2. **关系代数运算**
   - 集合运算：
     * 并(∪)：两个关系的所有元组，去除重复
     * 差(-)：在关系1中而不在关系2中的元组
     * 交(∩)：同时在两个关系中的元组
     * 笛卡尔积(×)：两个关系的所有可能元组组合
   
   - 专门运算：
     * 选择(σ)：
       - 功能：选取满足条件的元组
       - 示例：σ年龄>20(学生)
     * 投影(π)：
       - 功能：选取指定的列
       - 示例：π学号,姓名(学生)
     * 连接(⋈)：
       - 功能：基于条件组合两个关系
       - 类型：
         * 等值连接：基于相等条件
         * 自然连接：基于相同属性名
         * 外连接：保留不匹配的元组
     * 除(÷)：
       - 功能：求一个关系中满足另一个关系所有组合的元组
       - 应用：常用于"查询所有..."类型的问题

3. **数据库完整性**
   - 实体完整性：
     * 规则：主键非空且唯一
     * 实现：PRIMARY KEY约束
     * 示例：
     ```sql
     CREATE TABLE 学生 (
         学号 CHAR(10) PRIMARY KEY,
         姓名 VARCHAR(20) NOT NULL
     );
     ```
   
   - 参照完整性：
     * 规则：外键值必须存在于主表或为NULL
     * 实现：FOREIGN KEY约束
     * 示例：
     ```sql
     CREATE TABLE 选课 (
         学号 CHAR(10),
         课程号 CHAR(8),
         FOREIGN KEY (学号) REFERENCES 学生(学号)
         ON DELETE CASCADE -- 级联删除
         ON UPDATE CASCADE -- 级联更新
     );
     ```
   
   - 用户定义完整性：
     * CHECK约束：
     ```sql
     CREATE TABLE 学生 (
         年龄 INT CHECK (年龄 >= 0 AND 年龄 < 150),
         性别 CHAR(1) CHECK (性别 IN ('男','女'))
     );
     ```
     * DEFAULT约束：
     ```sql
     CREATE TABLE 员工 (
         入职日期 DATE DEFAULT CURRENT_DATE,
         状态 VARCHAR(10) DEFAULT '在职'
     );
     ```
     * UNIQUE约束：
     ```sql
     CREATE TABLE 用户 (
         邮箱 VARCHAR(50) UNIQUE,
         手机 CHAR(11) UNIQUE
     );
     ```

## 二、判断题（10分，10题）

### 关键知识点
1. **数据库设计过程**
   - 需求分析：
     * 目的：明确用户需求
     * 任务：收集数据、分析数据处理要求
     * 产出：需求说明书
     * 示例：学生管理系统需要管理学生信息、课程信息、成绩信息等
   
   - 概念设计：
     * 目的：建立概念模型
     * 工具：E-R图
     * 任务：设计实体、属性、关系
     * 示例：
       - 实体：学生、课程、教师
       - 关系：选课（学生-课程）、授课（教师-课程）
   
   - 逻辑设计：
     * 目的：将概念模型转换为逻辑模型
     * 任务：设计表结构、规范化处理
     * 工具：三范式理论
     * 示例：将E-R图转换为关系模式
       ```sql
       学生(学号, 姓名, 性别, 年龄)
       课程(课程号, 课程名, 学分)
       选课(学号, 课程号, 成绩)
       ```
   
   - 物理设计：
     * 目的：优化数据库性能
     * 任务：
       - 选择存储结构
       - 建立索引
       - 实现完整性约束
     * 示例：
       ```sql
       CREATE INDEX idx_student_name ON 学生(姓名);
       CREATE INDEX idx_score ON 选课(成绩);
       ```

2. **视图的特点**
   - 虚拟表特性：
     * 不存储实际数据
     * 基于基本表动态生成
     * 节省存储空间
     * 示例：
       ```sql
       -- 成绩汇总视图
       CREATE VIEW 成绩汇总 AS
       SELECT 学号, 
              COUNT(*) as 选课数,
              AVG(成绩) as 平均分
       FROM 选课
       GROUP BY 学号;
       ```

   - 简化查询：
     * 隐藏复杂的SQL逻辑
     * 重用常用查询
     * 示例：
       ```sql
       -- 使用视图简化查询
       SELECT * FROM 成绩汇总 
       WHERE 平均分 >= 80;
       ```

   - 安全性：
     * 限制用户只能访问特定字段
     * 控制数据访问权限
     * 示例：
       ```sql
       -- 限制查看的字段
       CREATE VIEW 学生基本信息 AS
       SELECT 学号, 姓名, 系别
       FROM 学生;
       
       -- 授权
       GRANT SELECT ON 学生基本信息 TO 普通用户;
       ```

   - 视图更新限制：
     * 可更新的条件：
       - 只涉及一个基本表
       - 包含主键列
       - 不包含聚合函数
     * 示例：
       ```sql
       -- 可更新的视图
       CREATE VIEW 计算机系学生 AS
       SELECT * FROM 学生
       WHERE 系别 = '计算机';
       
       -- 不可更新的视图
       CREATE VIEW 成绩统计 AS
       SELECT 系别, AVG(成绩) as 平均分
       FROM 学生 JOIN 选课
       ON 学生.学号 = 选课.学号
       GROUP BY 系别;
       ```

3. **事务的特性（ACID）**
   - 原子性（Atomicity）：
     * 定义：事务是最小的执行单位，要么全执行，要么全不执行
     * 实现：回滚日志（Undo Log）
     * 示例：
       ```sql
       START TRANSACTION;
       UPDATE 账户 SET 余额 = 余额 - 1000 WHERE 账号 = 'A';
       UPDATE 账户 SET 余额 = 余额 + 1000 WHERE 账号 = 'B';
       COMMIT;  -- 全部成功才提交
       ```

   - 一致性（Consistency）：
     * 定义：事务执行前后数据库都必须处于一致性状态
     * 体现：约束、触发器、级联操作
     * 示例：
       ```sql
       -- 转账前后总金额相同
       CREATE TRIGGER 检查余额
       BEFORE UPDATE ON 账户
       FOR EACH ROW
       BEGIN
           IF NEW.余额 < 0 THEN
               SIGNAL SQLSTATE '45000';
           END IF;
       END;
       ```

   - 隔离性（Isolation）：
     * 定义：并发事务之间互不干扰
     * 隔离级别：
       - READ UNCOMMITTED：读未提交
       - READ COMMITTED：读已提交
       - REPEATABLE READ：可重复读
       - SERIALIZABLE：串行化
     * 示例：
       ```sql
       SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
       START TRANSACTION;
       SELECT * FROM 账户 WHERE 账号 = 'A';
       -- 其他事务无法修改账号A的数据
       COMMIT;
       ```

   - 持久性（Durability）：
     * 定义：事务一旦提交，其修改是永久的
     * 实现：重做日志（Redo Log）
     * 示例：即使系统崩溃，重启后数据也不会丢失

## 三、SQL语句题（25分，5题）

### 1. 条件查询
1. **比较运算符**
```sql
-- 等于、不等于
SELECT * FROM 学生 WHERE 年龄 = 20;
SELECT * FROM 学生 WHERE 系别 != '计算机';

-- 范围查询
SELECT * FROM 学生 WHERE 年龄 BETWEEN 18 AND 22;
SELECT * FROM 成绩 WHERE 分数 >= 60 AND 分数 <= 100;
```

2. **模糊查询**
```sql
-- LIKE用法
SELECT * FROM 学生 WHERE 姓名 LIKE '张%';  -- 姓张
SELECT * FROM 学生 WHERE 姓名 LIKE '_华%'; -- 第二个字是华
SELECT * FROM 课程 WHERE 课程名 LIKE '%数据库%'; -- 包含数据库
```

3. **空值查询**
```sql
-- IS NULL和IS NOT NULL
SELECT * FROM 借阅 WHERE 还书时间 IS NULL;  -- 未还书记录
SELECT * FROM 学生 WHERE 电话 IS NOT NULL;  -- 有电话记录
```

### 2. 修改数据
1. **插入数据**
```sql
-- 单行插入
INSERT INTO 学生(学号, 姓名, 年龄) 
VALUES('001', '张三', 20);

-- 多行插入
INSERT INTO 学生(学号, 姓名, 年龄) 
VALUES ('002', '李四', 19),
       ('003', '王五', 21);

-- 基于查询结果插入
INSERT INTO 优秀学生(学号, 姓名)
SELECT 学号, 姓名 
FROM 学生 
WHERE 平均成绩 >= 90;
```

2. **更新数据**
```sql
-- 单表更新
UPDATE 学生 
SET 年龄 = 年龄 + 1 
WHERE 系别 = '计算机';

-- 多表更新
UPDATE 学生 s
JOIN 成绩 c ON s.学号 = c.学号
SET c.成绩 = c.成绩 * 1.1
WHERE c.成绩 < 60;
```

3. **删除数据**
```sql
-- 条件删除
DELETE FROM 选课 
WHERE 学号 = '001' 
AND 课程号 = 'C001';

-- 截断表（删除全部数据）
TRUNCATE TABLE 临时表;
```

### 3. 视图创建和使用
```sql
-- 简单视图
CREATE VIEW 学生信息视图 AS
SELECT 学号, 姓名, 系别
FROM 学生;

-- 复杂视图
CREATE VIEW 成绩统计视图 AS
SELECT s.系别, 
       COUNT(*) as 学生数,
       AVG(c.成绩) as 平均分
FROM 学生 s
JOIN 选课 c ON s.学号 = c.学号
GROUP BY s.系别;

-- 视图更新
UPDATE 学生信息视图
SET 系别 = '信息'
WHERE 学号 = '001';
```

### 4. 分组统计
1. **基本分组**
```sql
-- 单字段分组
SELECT 系别, COUNT(*) as 人数
FROM 学生
GROUP BY 系别;

-- 多字段分组
SELECT 系别, 年级, COUNT(*) as 人数
FROM 学生
GROUP BY 系别, 年级;
```

2. **分组后过滤**
```sql
-- HAVING子句
SELECT 课程号, 
       AVG(成绩) as 平均分,
       COUNT(*) as 选课人数
FROM 选课
GROUP BY 课程号
HAVING AVG(成绩) < 60
AND COUNT(*) >= 5;
```

3. **聚合函数**
```sql
-- 常用聚合函数
SELECT 系别,
       COUNT(*) as 总人数,
       AVG(年龄) as 平均年龄,
       MAX(成绩) as 最高分,
       MIN(成绩) as 最低分,
       SUM(学分) as 总学分
FROM 学生
GROUP BY 系别;
```

### 5. 多表查询
1. **内连接**
```sql
-- 等值连接
SELECT s.姓名, c.课程名, sc.成绩
FROM 学生 s
JOIN 选课 sc ON s.学号 = sc.学号
JOIN 课程 c ON sc.课程号 = c.课程号;

-- 自然连接
SELECT 学号, 姓名, 课程名, 成绩
FROM 学生 
NATURAL JOIN 选课
NATURAL JOIN 课程;
```

2. **外连接**
```sql
-- 左外连接
SELECT s.姓名, c.课程名
FROM 学生 s
LEFT JOIN 选课 sc ON s.学号 = sc.学号
LEFT JOIN 课程 c ON sc.课程号 = c.课程号;

-- 右外连接
SELECT c.课程名, s.姓名
FROM 选课 sc
RIGHT JOIN 课程 c ON sc.课程号 = c.课程号
LEFT JOIN 学生 s ON sc.学号 = s.学号;
```

## 四、数据库设计题（15分，2题）

### 1. ER图设计要点
1. **实体的表示**
   - 矩形表示实体型：
     * 强实体：用单边框矩形
     * 弱实体：用双边框矩形
     * 示例：学生（强实体）、家庭成员（弱实体）

   - 椭圆表示属性：
     * 普通属性：单边框椭圆
     * 多值属性：双边框椭圆
     * 主键属性：下划线表示
     * 复合属性：包含子属性
     * 示例：
       - 学生实体属性：
         * 主键属性：学号（下划线）
         * 普通属性：姓名、性别
         * 复合属性：地址（包含省、市、区）
         * 多值属性：特长（可以有多个）

   - 菱形表示关系：
     * 基本关系：单边框菱形
     * 标识性联系：双边框菱形
     * 弱实体依赖的关系必须是标识性联系
     * 示例：
       - "选课"关系连接学生和课程
       - "从属"关系（标识性）连接部门和弱实体员工

2. **联系的类型**
   - 一对一(1:1)关系：
     * 表示：─┼─
     * 特点：双方实体最多与对方一个实体相关
     * 示例：学生和学籍档案的关系
     * 映射约束：
       - (1,1)：必须且只能对应一个
       - (0,1)：最多对应一个
   
   - 一对多(1:n)关系：
     * 表示：─┼─<
     * 特点：一端实体可以关联多个另一端实体
     * 示例：系别和学生的关系
     * 常见约束：
       - (1,n)：必须关联至少一个
       - (0,n)：可以不关联或关联多个
   
   - 多对多(m:n)关系：
     * 表示：>─┼─<
     * 特点：双方实体都可以与对方多个实体相关
     * 示例：学生选课关系
     * 实现：需要创建中间表

3. **属性的类型**
   - 简单属性 vs 复合属性：
     * 简单属性：不可再分
       - 示例：姓名、年龄
     * 复合属性：可以再分
       - 示例：地址(省,市,区,街道)
   
   - 单值属性 vs 多值属性：
     * 单值属性：在一个实体中只有一个值
       - 示例：身份证号、性别
     * 多值属性：在一个实体中可以有多个值
       - 示例：联系电话、特长
   
   - 导出属性：
     * 特点：可由其他属性计算得出
     * 表示：虚线椭圆
     * 示例：
       - 年龄（由出生日期计算）
       - 平均成绩（由所有成绩计算）

4. **设计技巧**
   - 实体设计：
     * 识别系统中的主要对象
     * 区分强实体和弱实体
     * 确定每个实体的属性
   
   - 关系设计：
     * 明确实体间的联系
     * 确定联系的类型
     * 标注联系的约束条件
   
   - 属性设计：
     * 选择合适的主键
     * 识别派生属性
     * 处理多值属性

### 2. ER图转换规则
1. **实体转换**
```sql
-- 实体转换为表
CREATE TABLE 学生 (
    学号 CHAR(10) PRIMARY KEY,
    姓名 VARCHAR(20) NOT NULL,
    出生日期 DATE,
    性别 CHAR(1)
);
```

2. **一对一关系**
```sql
-- 外键方式
CREATE TABLE 学生 (
    学号 CHAR(10) PRIMARY KEY,
    姓名 VARCHAR(20)
);

CREATE TABLE 学籍档案 (
    档案号 CHAR(12) PRIMARY KEY,
    学号 CHAR(10) UNIQUE,
    入学日期 DATE,
    FOREIGN KEY (学号) REFERENCES 学生(学号)
);
```

3. **一对多关系**
```sql
-- 在"多"方加入外键
CREATE TABLE 系别 (
    系号 CHAR(6) PRIMARY KEY,
    系名 VARCHAR(40)
);

CREATE TABLE 学生 (
    学号 CHAR(10) PRIMARY KEY,
    姓名 VARCHAR(20),
    系号 CHAR(6),
    FOREIGN KEY (系号) REFERENCES 系别(系号)
);
```

4. **多对多关系**
```sql
-- 创建中间表
CREATE TABLE 学生 (
    学号 CHAR(10) PRIMARY KEY,
    姓名 VARCHAR(20)
);

CREATE TABLE 课程 (
    课程号 CHAR(8) PRIMARY KEY,
    课程名 VARCHAR(40)
);

CREATE TABLE 选课 (
    学号 CHAR(10),
    课程号 CHAR(8),
    成绩 INT,
    PRIMARY KEY (学号, 课程号),
    FOREIGN KEY (学号) REFERENCES 学生(学号),
    FOREIGN KEY (课程号) REFERENCES 课程(课程号)
);
```

## 五、关系规范化题（10分，2题）

### 1. 范式判断步骤
1. **确定码**
   - 找出所有函数依赖：
     * 观察数据语义
     * 分析属性间的依赖关系
     * 写出完整的函数依赖集
     * 示例：学生选课表中的函数依赖
       - 学号 → 姓名, 院系
       - 课程号 → 课程名, 学分
       - (学号, 课程号) → 成绩

   - 找出能够唯一标识元组的属性组：
     * 检查超键：能唯一标识元组的属性集
     * 确定候选键：最小的超键
     * 标记主属性：包含在任一候选键中的属性
     * 示例：
       - 超键：{学号,课程号}, {学号,课程号,姓名}
       - 候选键：{学号,课程号}
       - 主属性：学号,课程号
       - 非主属性：姓名,课程名,成绩等

2. **判断范式**
   - 第一范式(1NF)：
     * 定义：属性不可分
     * 判断方法：检查是否存在复合属性或多值属性
     * 示例：
       - 不符合1NF：
         ```
         学生(学号, 姓名, 联系方式(电话,邮箱), 特长[音乐,体育])
         ```
       - 符合1NF：
         ```
         学生(学号, 姓名, 电话, 邮箱)
         学生特长(学号, 特长)
         ```

   - 第二范式(2NF)：
     * 定义：不存在部分函数依赖
     * 判断步骤：
       1. 确定候选键
       2. 检查非主属性对候选键的依赖
     * 示例：
       - 不符合2NF：
         ```
         选课(学号, 课程号, 姓名, 课程名, 成绩)
         函数依赖：
         - (学号, 课程号) → 成绩
         - 学号 → 姓名 (部分依赖)
         - 课程号 → 课程名 (部分依赖)
         ```
       - 符合2NF：
         ```
         学生(学号, 姓名)
         课程(课程号, 课程名)
         选课(学号, 课程号, 成绩)
         ```

   - 第三范式(3NF)：
     * 定义：不存在传递函数依赖
     * 判断步骤：
       1. 找出所有函数依赖
       2. 检查非主属性对非主属性的依赖
     * 示例：
       - 不符合3NF：
         ```
         学生(学号, 姓名, 系名, 系主任)
         函数依赖：
         - 学号 → 姓名, 系名
         - 系名 → 系主任 (传递依赖)
         ```
       - 符合3NF：
         ```
         学生(学号, 姓名, 系名)
         系别(系名, 系主任)
         ```

   - BCNF：
     * 定义：不存在主属性对码的依赖
     * 判断步骤：
       1. 找出所有决定因素
       2. 检查是否都是码
     * 示例：
       - 不符合BCNF：
         ```
         课程安排(学生, 课程, 教师)
         码：{学生,课程}, {学生,教师}
         函数依赖：
         - 教师 → 课程 (主属性对码的依赖)
         ```
       - 符合BCNF：
         ```
         教师课程(教师, 课程)
         学生选课(学生, 教师)
         ```

### 2. 规范化示例
原表：
课程选修(学号, 姓名, 课程号, 课程名, 分数, 教师, 教师办公室)

函数依赖分析：
1. 完整的函数依赖集：
   - 学号 → 姓名
   - 课程号 → 课程名, 教师
   - 教师 → 教师办公室
   - (学号, 课程号) → 分数

2. 候选键分析：
   - 主键为(学号, 课程号)
   - 主属性：学号, 课程号
   - 非主属性：姓名, 课程名, 分数, 教师, 教师办公室

3. 范式判断：
   - 属性都是原子的，满足1NF
   - 存在对主键的部分函数依赖，不满足2NF
   - 存在非主属性间的传递依赖，不满足3NF

规范化过程：
1. **消除部分函数依赖（转换为2NF）**
   * 分析：
     - 学号 → 姓名（部分依赖）
     - 课程号 → 课程名,教师（部分依赖）
   * 拆分：
     ```sql
     -- 学生表：存储学生基本信息
     CREATE TABLE 学生 (
         学号 CHAR(10) PRIMARY KEY,
         姓名 VARCHAR(20) NOT NULL
     );

     -- 课程关系表：保留主键和成绩
     CREATE TABLE 课程选修中间表 (
         学号 CHAR(10),
         课程号 CHAR(8),
         课程名 VARCHAR(40),
         分数 INT,
         教师 VARCHAR(20),
         教师办公室 VARCHAR(30),
         PRIMARY KEY (学号, 课程号),
         FOREIGN KEY (学号) REFERENCES 学生(学号)
     );
     ```

2. **消除传递依赖（转换为3NF）**
   * 分析：
     - 教师 → 教师办公室（传递依赖）
     - 课程号 → 教师（传递依赖）
   * 拆分：
     ```sql
     -- 教师表：处理教师和办公室的依赖
     CREATE TABLE 教师 (
         教师编号 CHAR(8) PRIMARY KEY,
         教师姓名 VARCHAR(20) NOT NULL,
         办公室 VARCHAR(30)
     );

     -- 课程表：处理课程相关信息
     CREATE TABLE 课程 (
         课程号 CHAR(8) PRIMARY KEY,
         课程名 VARCHAR(40) NOT NULL,
         教师编号 CHAR(8),
         FOREIGN KEY (教师编号) REFERENCES 教师(教师编号)
     );

     -- 选课表：最终的3NF表
     CREATE TABLE 选课 (
         学号 CHAR(10),
         课程号 CHAR(8),
         分数 INT,
         PRIMARY KEY (学号, 课程号),
         FOREIGN KEY (学号) REFERENCES 学生(学号),
         FOREIGN KEY (课程号) REFERENCES 课程(课程号)
     );
     ```

3. **验证最终结果**
   * 检查要点：
     - 所有属性都是原子的（满足1NF）
     - 不存在部分函数依赖（满足2NF）
     - 不存在传递函数依赖（满足3NF）
   * 优点：
     - 消除了数据冗余
     - 避免了异常操作
     - 提高了数据一致性
   * 实例数据：
     ```sql
     -- 插入测试数据
     INSERT INTO 学生 VALUES ('001', '张三');
     INSERT INTO 教师 VALUES ('T001', '王老师', 'A101');
     INSERT INTO 课程 VALUES ('C001', '数据库', 'T001');
     INSERT INTO 选课 VALUES ('001', 'C001', 85);
     
     -- 查询学生成绩（多表联接）
     SELECT s.姓名, c.课程名, t.教师姓名, sc.分数
     FROM 学生 s
     JOIN 选课 sc ON s.学号 = sc.学号
     JOIN 课程 c ON sc.课程号 = c.课程号
     JOIN 教师 t ON c.教师编号 = t.教师编号;
     ```

## 考试答题要点

### 1. 选择题技巧
- 重点关注概念之间的区别
- 理解并记忆专业术语的准确定义
- 注意题目中的关键词

### 2. SQL语句题技巧
- 仔细阅读表结构和数据要求
- 条件查询注意WHERE和HAVING的使用场景
- 多表查询先确定关联条件
- 分组统计先确定分组字段

### 3. 设计题技巧
- ER图要画得规范清晰
- 注意标注实体、属性和关系的类型
- 转换规则要准确运用

### 4. 规范化题技巧
- 完整列出所有函数依赖
- 说明判断范式的理由
- 规范化分解要完整且合理

祝考试顺利！
